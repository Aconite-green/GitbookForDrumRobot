# Real-Time OS

#### 1. 서론

**리얼타임 운영체제의 개념과 중요성**

현대 기술의 세계에서, 시스템의 신속한 반응은 필수적입니다. 이러한 필요성이 바로 리얼타임 운영체제(Real-Time Operating System, RTOS)의 중요성을 강조하는 이유입니다. 리얼타임 OS는 특정 작업을 정해진 시간 내에 일관되고 예측 가능한 방식으로 처리할 수 있는 시스템입니다. 이는 공장 자동화, 의료 장비, 로봇 공학 등 다양한 분야에서 중요한 역할을 합니다.

기존 운영체제와 리얼타임 OS의 가장 큰 차이점은 '시간의 정확성'에 있습니다. 일반적인 운영체제는 다양한 작업을 처리하는데 초점을 맞추지만, 리얼타임 OS는 정확한 시간 안에 특정 작업을 완료하는 것이 핵심입니다. 이러한 특성 때문에 리얼타임 시스템은 예측 가능성과 신뢰성이 매우 높아야 합니다.

**리눅스 기반 리얼타임 시스템의 장점**

리눅스는 그 자체로 강력하고 유연한 운영체제입니다. 리얼타임 환경에서 리눅스를 사용하면 여러 가지 장점이 있습니다. 첫째, 리눅스는 오픈 소스이기 때문에 사용자가 시스템을 자신의 필요에 맞게 맞춤화하고 최적화할 수 있습니다. 둘째, 리눅스는 널리 사용되는 운영체제이므로, 대규모의 지원 커뮤니티와 방대한 문서 자료를 활용할 수 있습니다. 셋째, 리눅스는 다양한 하드웨어와 호환되며, 특히 서버와 임베디드 시스템에서 강력한 성능을 발휘합니다.

우분투 20.04와 같은 리눅스 배포판은 이러한 리눅스의 장점을 기반으로 하면서도 사용자 친화적인 환경을 제공합니다. 이는 리얼타임 시스템을 구축하고자 하는 개발자들에게 매력적인 선택지가 됩니다.

**본 글의 목적**

이 글에서는 리눅스 우분투 환경에서 리얼타임 OS를 구축하는 방법에 대해 탐구할 것입니다. 특히, 우분투 20.04를 기반으로 한 리얼타임 커널의 설치 및 구성, 그리고 C++을 사용한 응용 프로그램 개발에 중점을 둘 것입니다. 이를 통해 독자들은 리얼타임 시스템의 기본 개념을 이해하고, 실제로 리얼타임 OS를 구축하는 데 필요한 지식과 기술을 습득할 수 있을 것입니다.

\


#### 2. 리얼타임 OS의 기본 개념

**정의 및 원리**

리얼타임 시스템이란 특정한 시간 제약 조건 내에서 데이터를 처리하고 결과를 제공하는 컴퓨팅 시스템을 말합니다. 이러한 시스템에서는 처리 속도뿐만 아니라 '시간'이 매우 중요한 요소로 작용합니다. 즉, 계산이 정확하게 수행되는 것뿐만 아니라, 그 결과가 정해진 시간 안에 도출되어야 합니다.

리얼타임 시스템의 핵심 원리는 '결정성'과 '응답성'입니다. 결정성은 주어진 입력에 대해 시스템이 항상 동일한 반응을 보이는 성질을 의미하며, 응답성은 시스템이 빠르고 예측 가능한 시간 안에 반응하는 능력을 가리킵니다. 이러한 원리는 시스템이 예측 불가능한 지연 없이 안정적으로 작동하도록 보장하는 데 필수적입니다.

**종류 및 적용 분야**

리얼타임 시스템은 크게 두 가지 유형으로 나뉩니다: 소프트 리얼타임 시스템과 하드 리얼타임 시스템.

1. **소프트 리얼타임 시스템**: 이 시스템에서는 시간 제약 조건을 충족하지 못해도 시스템의 전체 기능성에 치명적인 영향을 주지 않습니다. 예를 들어, 비디오 스트리밍이나 온라인 게임과 같은 응용 프로그램에서 약간의 지연이 발생해도 전체 사용자 경험에 큰 영향을 미치지 않습니다.
2. **하드 리얼타임 시스템**: 이 유형의 시스템에서는 시간 제약을 엄격하게 준수해야 합니다. 시간 제약을 지키지 못하면 시스템의 기능성에 심각한 문제가 발생할 수 있습니다. 예를 들어, 항공기 제어 시스템, 의료 장비, 산업 자동화 시스템 등이 이에 해당합니다.

이 두 유형의 차이점은 시간 제약 위반 시의 영향 정도에 있습니다. 소프트 리얼타임 시스템은 일부 지연을 허용하지만, 하드 리얼타임 시스템에서는 그러한 여유가 없습니다. 이러한 차이점은 각 시스템의 설계와 구현 방법에도 중요한 영향을 미칩니다.

\
알겠습니다. "3. 리얼타임 커널 패치" 섹션을 작성해드리겠습니다. 이 부분은 리얼타임 패치의 필요성과 이를 적용하는 구체적인 방법을 단계별로 설명하는 내용으로 구성될 것입니다.

***

#### 3. 리얼타임 커널 패치

**패치의 필요성**

리얼타임 커널 패치는 표준 리눅스 커널을 리얼타임 요구 사항에 맞게 수정하는 것입니다. 표준 리눅스 커널은 다양한 작업을 효율적으로 처리하는 데 최적화되어 있지만, 엄격한 시간 제약을 가진 리얼타임 작업에는 적합하지 않을 수 있습니다. 리얼타임 패치를 적용하면, 커널은 더 낮은 지연 시간과 더 높은 예측 가능성을 제공하여, 시간에 민감한 작업을 더 잘 처리할 수 있게 됩니다.

이 패치는 주로 커널 스케줄링과 인터럽트 처리 방식을 개선하여, 시스템이 더 신속하고 일관된 반응 시간을 가질 수 있도록 합니다. 이는 특히 자동화된 제조, 의료 기기, 로봇 공학 등에서 중요한 역할을 합니다.

**적용 방법**

1. **환경 준비**:
   * 우선, 사용 중인 리눅스 배포판과 커널 버전을 확인합니다.
   * 필요한 개발 도구와 라이브러리를 설치합니다 (예: `build-essential`, `libncurses-dev`).
2. **패치 다운로드**:
   * 리얼타임 패치는 [리눅스 커널 아카이브](https://www.kernel.org/)에서 다운로드할 수 있습니다.
   * 사용 중인 커널 버전에 맞는 패치를 선택합니다.
3. **커널 소스 다운로드 및 추출**:
   * 커널 소스도 리눅스 커널 아카이브에서 다운로드합니다.
   * 다운로드한 커널 소스를 압축 해제합니다.
4. **패치 적용**:
   * 압축 해제한 커널 소스 디렉토리로 이동합니다.
   * `patch` 명령어를 사용하여 리얼타임 패치를 적용합니다.
5. **커널 구성**:
   * `make menuconfig` 명령어를 사용하여 커널을 구성합니다.
   * 리얼타임 관련 옵션들을 활성화합니다.
6. **커널 컴파일 및 설치**:
   * `make` 명령어를 사용하여 커널을 컴파일합니다.
   * 컴파일이 완료되면 `make modules_install`과 `make install` 명령어를 사용하여 설치합니다.
7. **부팅 로더 설정**:
   * 설치된 리얼타임 커널로 시스템이 부팅되도록 부팅 로더를 설정합니다.
8. **재부팅 및 검증**:
   * 시스템을 재부팅하여 새 커널이 정상적으로 작동하는지 확인합니다.

#### 4. 리얼타임 OS 환경 구축

**커널 설정 및 튜닝**

리얼타임 커널을 설치한 후에는 성능을 최적화하기 위해 추가적인 설정과 튜닝이 필요합니다. 이 과정은 시스템이 리얼타임 작업에 최적화되도록 보장하는 중요한 단계입니다.

1. **커널 매개변수 조정**:
   * 시스템 부팅 시 커널 매개변수를 조정하여 성능을 향상시킬 수 있습니다.
   * 예를 들어, `isolcpus` 매개변수를 사용하여 특정 CPU 코어를 일반 스케줄링에서 제외시킬 수 있습니다.
2. **인터럽트 어피니티 설정**:
   * 리얼타임 시스템에서는 인터럽트 처리가 중요한 역할을 합니다.
   * 특정 CPU 코어에 인터럽트를 할당하여 처리 효율을 높일 수 있습니다.
3. **메모리 할당 최적화**:
   * `mlockall()` 함수를 사용하여 프로세스의 메모리를 물리 메모리에 고정시키는 방법이 있습니다.
   * 이렇게 하면 페이지 폴트를 방지하여 시스템의 반응 시간을 개선할 수 있습니다.
4. **실시간 우선 순위 설정**:
   * 프로세스나 스레드에 대한 실시간 우선 순위를 설정하여, 중요한 작업이 더 높은 CPU 시간을 얻도록 합니다.
   * `chrt` 명령어를 사용하여 우선 순위를 조정할 수 있습니다.

**성능 테스트**

리얼타임 시스템의 성능을 평가하는 것은 시스템이 요구 사항을 만족시키는지 확인하는 데 필수적입니다.

1. **지연 시간 측정**:
   * `cyclictest`와 같은 도구를 사용하여 커널의 지연 시간을 측정할 수 있습니다.
   * 이 도구는 인터럽트 지연과 스케줄링 지연을 측정하여, 시스템의 실시간 성능을 평가합니다.
2. **스루풋 테스트**:
   * 시스템의 스루풋(처리량)을 측정하여, 시스템이 얼마나 많은 작업을 효율적으로 처리할 수 있는지 평가합니다.
   * `stress` 또는 `stress-ng` 도구를 사용하여 CPU, 메모리, I/O 등을 집중적으로 사용하는 작업을 생성하고 성능을 측정합니다.
3. **응답 시간 테스트**:
   * 실제 응용 프로그램을 실행하여 시스템의 응답 시간을 측정합니다.
   * 이는 시스템이 실제 운영 환경에서 어떻게 작동하는지 평가하는 데 도움이 됩니다.

#### 5. 리얼타임 응용 프로그램 개발

**C++ 프로그래밍 원칙**

리얼타임 시스템에서 C++을 사용할 때는 특별한 주의가 필요합니다. C++은 성능과 유연성을 제공하지만, 리얼타임 시스템의 요구 사항에 맞추기 위한 몇 가지 기본 원칙을 따라야 합니다.

1. **결정성 보장**:
   * 리얼타임 시스템에서는 코드가 항상 예측 가능한 시간 안에 실행되어야 합니다.
   * 함수 호출 시간, 루프 실행 시간 등을 고려하여 결정성을 보장해야 합니다.
2. **동적 할당 최소화**:
   * 동적 메모리 할당은 시간을 예측하기 어렵게 만들 수 있으므로, 가능한 한 사용을 피하거나 초기화 단계에서만 사용합니다.
   * `std::vector`, `std::string` 등의 표준 라이브러리 사용 시에도 주의가 필요합니다.
3.  **실시간 우선 순위 고려**:

    * 스레드 또는 태스크마다 적절한 실시간 우선 순위를 설정합니다.
    * 우선 순위 역전 문제를 피하기 위해 우선 순위 상속 또는 우선 순위 천정 프로토콜을 사용할 수 있습니다.



    \
    리눅스와 같은 POSIX 기반 시스템에서 사용하는 주요 스케줄링 정책은 다음과 같습니다:

    1. **SCHED\_OTHER**: 기본 스케줄링 정책으로, 시분할(time-sharing) 스케줄링을 사용합니다. 이 정책은 일반 사용자 수준의 작업에 주로 사용되며, 프로세스는 동적 우선순위를 가집니다. 일반적인 데스크탑이나 서버 환경에서 사용됩니다.
    2. **SCHED\_FIFO (First In, First Out)**: 실시간 스케줄링 정책 중 하나로, 프로세스는 선입선출 방식으로 실행됩니다. 한 번 CPU를 획득한 프로세스는 높은 우선순위의 새로운 프로세스가 도착하거나 자발적으로 CPU를 방출할 때까지 CPU를 점유합니다. 실시간 작업에서 요구되는 엄격한 시간 제약을 만족하는 환경에 적합합니다.
    3. **SCHED\_RR (Round Robin)**: SCHED\_FIFO와 유사하지만, 각 프로세스는 설정된 시간 한도(time quantum) 내에서만 실행됩니다. 시간 한도가 지나면, 같은 우선순위를 가진 다른 프로세스에게 CPU를 양도합니다. 이 정책은 시간 공유를 보다 공정하게 하여, 같은 우선순위를 가진 여러 실시간 작업을 처리할 때 유용합니다.
    4. **SCHED\_BATCH**: 배치 처리에 최적화된 스케줄링 정책으로, 대화형 프로세스보다 배치 처리 프로세스에 더 높은 우선순위를 부여합니다. CPU 사용이 많은 작업에 적합하며, 작업의 응답 시간보다 처리량을 중시할 때 사용됩니다.
    5. **SCHED\_IDLE**: 이 정책 하에 있는 프로세스는 시스템이 유휴 상태일 때만 CPU 자원을 사용합니다. 다른 모든 작업이 완료된 후에 실행되는 낮은 우선순위 작업에 적합합니다.



```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <pthread.h>

// 상태 머신을 관리하는 스레드
void stateMachineThread() {
    while (true) {
        // 상태 머신 로직...
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 예시 대기 시간
    }
}

// 5ms마다 CAN 프레임을 보내는 스레드
void sendCanFrameThread() {
    while (true) {
        // CAN 프레임 보내는 로직...
        std::this_thread::sleep_for(std::chrono::milliseconds(5));
    }
}

// 100ms마다 CAN 프레임을 받는 스레드
void receiveCanFrameThread() {
    while (true) {
        // CAN 프레임 받는 로직...
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

// 스레드 우선순위 설정 함수
bool setThreadPriority(std::thread &th, int priority, int policy = SCHED_FIFO) {
    sched_param sch_params;
    sch_params.sched_priority = priority;
    if(pthread_setschedparam(th.native_handle(), policy, &sch_params)) {
        std::cerr << "Failed to set Thread scheduling : " << std::strerror(errno) << std::endl;
        return false;
    }
    return true;
}

int main() {
    // 스레드 생성
    std::thread stateMachine(stateMachineThread);
    std::thread sendCanFrame(sendCanFrameThread);
    std::thread receiveCanFrame(receiveCanFrameThread);

    // 스레드 우선순위 설정
    if(!setThreadPriority(sendCanFrame, 3)) {
        std::cerr << "Error setting priority for sendCanFrame" << std::endl;
        return -1;
    }
    if(!setThreadPriority(receiveCanFrame, 2)) {
        std::cerr << "Error setting priority for receiveCanFrame" << std::endl;
        return -1;
    }
    if(!setThreadPriority(stateMachine, 1)) {
        std::cerr << "Error setting priority for stateMachine" << std::endl;
        return -1;
    }

    // 스레드 작업 수행
    stateMachine.join();
    sendCanFrame.join();
    receiveCanFrame.join();

    return 0;
}

```
